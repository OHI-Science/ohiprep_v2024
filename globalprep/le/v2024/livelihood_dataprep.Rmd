---
title: "OHI `r format(Sys.Date(), '%Y')` - Livelilihoods Data Preparation"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: show
    toc: true
    toc_depth: 1
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '../../../workflow/templates/ohi_hdr.html'
pdf_document:
  toc: true
editor_options: 
  chunk_output_type: inline
  markdown: 
    wrap: 72
---

# Livelihoods: Proportion of Tourism Jobs per Country/Region per Year

## Overview

* **Data:** Labor Force & Employment Data

  * Labor Force data from World Bank (downloaded June 28. 2024)

- https://data.worldbank.org/indicator/SL.TLF.TOTL.IN


### Setup

```{r}
# load packages
if (!require(librarian)){
  install.packages("librarian")
  library(librarian)
}
librarian::shelf(
  here,
  janitor,
  terra,
  readxl,
  RColorBrewer,
  foreach,
  doParallel, # for using multiple cores
  tidyverse, 
  httr,
  plotly,
  zoo # for gapfilling
  
)
#remotes::install_github("skgrange/threadr") # for na_extrapolate
library(threadr)


# source 
source(here("workflow/R/common.R"))

# set year and file path info
current_year <- 2024 # Update this!!

version_year <- paste0("v",current_year)
data_dir_version_year <- paste0("d", current_year)
data_path <- paste0("globalprep/le/", version_year)

# Raw data directory (on Mazu)
raw_data_dir <- here::here(dir_M, "git-annex", "globalprep", "_raw_data")

# world bank raw data directory
wb_dir <- here(raw_data_dir, "WorldBank", data_dir_version_year)
```

### Read in Data

```{r}
# ===================== Read in Data ==============================


# Labor force data ----
labor_raw <- readxl::read_xls(here(wb_dir, "worldbank_labor_force_raw.xls"),
                               skip = 3,
                               na = "")

# OHI regions data ----
# read in OHI regions for joining
region_names <- read_csv("https://raw.githubusercontent.com/OHI-Science/ohi-global/draft/eez/spatial/regions_list.csv") 


# ILO wage data ----
# define file path to ILO wage data 
ilo_fp <- file.path(dir_M,
                        "git-annex/globalprep/_raw_data/UNWTO/d2024/EAR_4MTH_SEX_ECO_CUR_NB_A-filtered-2024-06-28.csv")

# read in ILO wage data
ilo_wage_data <- read_csv(ilo_fp)


# ==================== Tidy Data ===================================

# Labor force data -----------------------------------
labor_clean <- labor_raw %>% 
  # conver to lower_snake_case
  janitor::clean_names() %>% 
  # tidy data from wide to long (years are currently columns)
  pivot_longer(cols = 5:length(names(labor_raw)),
               names_to = "year", 
               values_to = "thousand_jobs") %>% 
  # remove unnecessary columns
  select(-c(indicator_name, indicator_code)) %>% 
  # clean up year column (currently in the form of xYYYY)
  mutate(year = str_remove_all(year, pattern = "x")) %>% 
  # fix data types
  mutate(year = as.numeric(year),
         country_name = as.factor(country_name),
         thousand_jobs = as.numeric(thousand_jobs))
  

# clean regions data --------------
region_clean <- region_names %>% 
  janitor::clean_names() %>% 
  # drop notes column
  select(-c(("notes")))



# ============== Join labor force + OHI regions =============================

labor_regions_join <- left_join(region_clean, labor_clean,
                                by = c("eez_iso3" = "country_code"))
# note: many-to-many warning is not a cause for concern here because for countries in the labor dataset that match admin countries (but not region names) in the region dataset, it'll populate the rows of region-admin country pairs where there is only a match between admin and labor country names with that country's admin-country-level labor data. It will be important to mention this in the data gaps or analysis, however.


labor_regions <- labor_regions_join %>% 
  select(-c(country_name)) %>% 
  filter(year >= 2009) # starting 5 years back from first year of evaluation

```

# Employment Data

(put this within previous chunk, read in data etc. for number of tourism jobs, join with labor_regions, make new proportion of tourism jobs column, group by year, do prelim plotting etc. and evaluate data quality etc.)

```{r}
# total number of people employed by the tourism sector, in thousands (remember this!)
un_job_data <- file.path(dir_M, "git-annex/globalprep/_raw_data/UNWTO/d2024/unwto-all-data-download_0.xlsx")

# take in .xlsx and read it in, clean it
un_jobs_data_raw <- read_xlsx(un_job_data, skip = 2, sheet = "Employment", col_names = TRUE, na = c("","..")) %>%
  janitor::clean_names() %>%
  select(-c(1:3)) %>%
  fill(1, .direction = "down") %>%
  select(-c(x5, x7:units, notes, x38)) %>%
  filter(x6 %in% "Total") %>%
  select(-x6)

# pivot longer so that we can see how many jobs per year, per country!
un_jobs_data_piv <- un_jobs_data_raw %>%
  pivot_longer(cols = 2:28, names_to = "year", values_to = "jobs") %>%
  mutate(year = str_remove_all(year, 'x')) %>%
  rename(country = basic_data_and_indicators) %>%
  mutate()

# install.packages("countrycode")
library(countrycode)

country_regex_to_iso3c <- function(country_string) {
  country_string %>%
    countrycode::countrycode(origin = "country.name", destination = "iso3c", origin_regex = TRUE)
}

# adding iso3 codes, converting number to thousands to be consistent and prep for the left_join with labor_regions
un_jobs_cc <- un_jobs_data_piv %>% 
  mutate(iso3c = country_regex_to_iso3c(country)) %>%
  mutate(tourism_jobs = jobs*1000) %>%
  mutate(country = str_to_title(country)) %>%
  select(-jobs) %>%
  mutate(year = as.numeric(year))
# warning: ! Some values were not matched unambiguously: BONAIRE, SABA, SERBIA AND MONTENEGRO, SINT EUSTATIUS

# join w OHI regions
tourism_un_jobs_ohi <- left_join(region_clean, un_jobs_cc, by = c("eez_iso3" = "iso3c"))


# ----------Join with Labor Force Data--------------
tourism_labor_join <- left_join(labor_regions, tourism_un_jobs_ohi, by = c("rgn_id", "year")) 
```

Create the proportion between tourism jobs and the total labor force
```{r}
tourism_job_proportion <- tourism_labor_join %>%
  dplyr::relocate(tourism_jobs, .before = thousand_jobs) %>%
  mutate(tourism_proportion = tourism_jobs/thousand_jobs) %>%
  rename(labor_force_total = thousand_jobs) %>%
  select(rgn_id, rgn_name.x, country, year, labor_force_total, tourism_jobs, tourism_proportion)

# plot it, interactively!
line_plot <- plotly::plot_ly(tourism_job_proportion, x = ~year, y = ~tourism_proportion, color = ~country, type = "scatter", mode = "lines") %>% 
  layout(title = "All Regions: Proportional Tourism Employment Within Total Labor Force", 
         xaxis = list(title = "Year"),
         yaxis = list(title = "Percent of people by region employed by the tourism sector"))

line_plot

# htmlwidgets::saveWidget(line_plot, file = "prop_tourism_laborforce.html")
```


## ILO wage data
  - note: this data came from many sources and was compiled by ILO

```{r}
# preliminary cleanings
wage_data_clean <- ilo_wage_data %>% 
  # lower_snake_case
  janitor::clean_names() %>% 
  # more intuitive value name
  rename(monthly_wage = obs_value) %>% 
  # filter to PPP adjusted data (this accounts for inflation, diff in currencies globally, cost of living etc.)
  filter(classif2_label == "Currency: 2017 PPP $") %>% 
  # group by country/region
  group_by(ref_area_label) %>% 
  # set column name to year
  rename(year = time) %>% 
  # filter to the cap date range from the jobs data -- 2019
  filter(year %in% c(2014:2019)) %>%  
  # add iso3 column, tourism sector label
  mutate(iso3 = country_regex_to_iso3c(ref_area_label),
         sector = "tour") %>% 
  select(c(ref_area_label, iso3, year, monthly_wage, classif2_label))
  


# make sequence of years for gapfilling ----
# note: data does not have wage data for some years in some countries -- we want to account for that by leaving them as NAs, then gapfilling with the average between the pre and post years

years_df <- tibble(iso3 = wage_data_clean$iso3) %>% 
  group_by(iso3) %>% 
  summarize(year = seq(2014, 2019))


wage_data_years <- left_join(years_df, wage_data_clean, by = c("iso3", "year"))

# filling in country names when possible --- 
wage_years_filled <- wage_data_years %>% 
  group_by(iso3) %>% 
  fill(ref_area_label, .direction = "downup") %>% 
  ungroup()

# =================

# test gapfilling
gap_fill_test <- wage_years_filled %>% 
  mutate(ref_area_label = as.factor(ref_area_label)) %>% 
  mutate(lm_est = list(lm(monthly_wage ~ year + ref_area_label)))


lm_test <- lm(monthly_wage ~ year + ref_area_label, data = wage_years_filled)
summary(lm_test)

lm_test$coefficients 

# wage_years_filled$lm_values <- lm_test$fitted.values

# gap filling  ----
wage_gf <- wage_years_filled %>% 
  group_by(ref_area_label) %>% 
  # interpolate (fill missing values between 2 values)
  mutate(appx_wage = zoo::na.approx(monthly_wage, # using values in this column
                                    na.rm = FALSE, # don't replace (internal) NAs in new column that can't be approximated
                                    #  extrapolate using rule = 2 from approx(),
                                    # uses closest data extreme to extrapolate 
                                    # for leading and trailing NAs
                                    rule = 2)) %>% 
  
  # fill NA values with the only other observed value (making sure to note the list of countries/regions we did this for)
  mutate(appx_wage_fill = zoo::na.aggregate(appx_wage, by = 1, FUN = mean, na.rm = FALSE))
# note: made this a new column so that we can still identify each country that we are using this fill (na.aggregate function) method for.
  
# other notes: 
# need more than 1 data point to do any approximation. 
# also, extremes (leading and trailing) are just copied data points from nearest extreme

```



```{r}
# find regions with only 1 data point (still have NAs in appx_wage column)

na_regions <- wage_gf %>% 
  filter(is.na(appx_wage))


unique(na_regions$ref_area_label)
num_na <- length(unique(na_regions$ref_area_label))
num_tot <- length(unique(wage_gf$ref_area_label))

paste0("proportion of countries/regions with only 1 data point: ", round(((num_na / num_tot) * 100), 3), "%")
```







```{r}
# preliminary plotting ----
# select random countries for preliminary plot
country <- as.data.frame(unique(wage_data_ppp$ref_area_label))

countries = sample_n(country, size = 15)

#countries = as.list(countries[,1])

test <- wage_data_ppp[wage_data_ppp$ref_area_label %in% countries[,1], ]

range(wage_data_ppp$time) ## 2014-2024 
length(unique(wage_data_ppp$ref_area_label)) ## 150 countries

# preliminary plot of random countries
ggplot(test, aes(x = time, y = monthly_wage, color = ref_area_label)) + 
  geom_point() + 
  geom_smooth(method = "lm") +
  ylim(0, 10000)
```


Clean up ILO data, join with OHI regions

```{r}
# join with OHI regions
wage_region_join <- left_join(region_clean, wage_gf, by = c("eez_iso3" = "iso3"))

# come back ---- stopping point for Mel to take a look!

# Currency: 2017 PPP $

wage_regions <- wage_region_join %>% 
  mutate(unit = "Currency: 2017 PPP $") %>% 
  select(-classif2_label)

```

